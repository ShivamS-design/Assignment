package testdata

import (
	"crypto/rand"
	"encoding/binary"
	"fmt"
	"math"
)

type WasmGenerator struct{}

func NewWasmGenerator() *WasmGenerator {
	return &WasmGenerator{}
}

func (g *WasmGenerator) SimpleAddModule() []byte {
	return []byte{
		0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, // WASM header
		0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01, 0x7f, // Type section
		0x03, 0x02, 0x01, 0x00, // Function section
		0x07, 0x07, 0x01, 0x03, 0x61, 0x64, 0x64, 0x00, 0x00, // Export section
		0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b, // Code section
	}
}

func (g *WasmGenerator) FibonacciModule() []byte {
	return []byte{
		0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
		0x01, 0x06, 0x01, 0x60, 0x01, 0x7f, 0x01, 0x7f,
		0x03, 0x02, 0x01, 0x00,
		0x07, 0x07, 0x01, 0x03, 0x66, 0x69, 0x62, 0x00, 0x00,
		0x0a, 0x1f, 0x01, 0x1d, 0x00, 0x20, 0x00, 0x41, 0x02, 0x49,
		0x04, 0x40, 0x20, 0x00, 0x0f, 0x0b, 0x20, 0x00, 0x41, 0x02,
		0x6b, 0x10, 0x00, 0x20, 0x00, 0x41, 0x01, 0x6b, 0x10, 0x00, 0x6a, 0x0b,
	}
}

func (g *WasmGenerator) MemoryTestModule() []byte {
	return []byte{
		0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
		0x05, 0x03, 0x01, 0x00, 0x01, // Memory section: 1 page
		0x01, 0x05, 0x01, 0x60, 0x00, 0x01, 0x7f,
		0x03, 0x02, 0x01, 0x00,
		0x07, 0x0c, 0x01, 0x08, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65, 0x00, 0x00,
		0x0a, 0x07, 0x01, 0x05, 0x00, 0x41, 0x00, 0x40, 0x00, 0x0b,
	}
}

func (g *WasmGenerator) MaliciousModule(attackType string) []byte {
	switch attackType {
	case "infinite_loop":
		return g.infiniteLoopModule()
	case "memory_bomb":
		return g.memoryBombModule()
	case "stack_overflow":
		return g.stackOverflowModule()
	default:
		return g.SimpleAddModule()
	}
}

func (g *WasmGenerator) RandomFuzzData(size int) []byte {
	data := make([]byte, size)
	rand.Read(data)
	
	// Sometimes make it look like valid WASM
	if size >= 8 && rand.Intn(2) == 0 {
		copy(data[:4], []byte{0x00, 0x61, 0x73, 0x6d})
		binary.LittleEndian.PutUint32(data[4:8], 1)
	}
	
	return data
}

func (g *WasmGenerator) infiniteLoopModule() []byte {
	return []byte{
		0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
		0x01, 0x04, 0x01, 0x60, 0x00, 0x00,
		0x03, 0x02, 0x01, 0x00,
		0x07, 0x08, 0x01, 0x04, 0x6c, 0x6f, 0x6f, 0x70, 0x00, 0x00,
		0x0a, 0x06, 0x01, 0x04, 0x00, 0x03, 0x40, 0x0c, 0x00, 0x0b, 0x0b,
	}
}

func (g *WasmGenerator) memoryBombModule() []byte {
	return []byte{
		0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
		0x05, 0x04, 0x01, 0x01, 0x00, 0x10, // Memory: min=0, max=16 pages
		0x01, 0x05, 0x01, 0x60, 0x00, 0x01, 0x7f,
		0x03, 0x02, 0x01, 0x00,
		0x07, 0x08, 0x01, 0x04, 0x62, 0x6f, 0x6d, 0x62, 0x00, 0x00,
		0x0a, 0x08, 0x01, 0x06, 0x00, 0x41, 0x10, 0x40, 0x00, 0x1a, 0x0b,
	}
}

func (g *WasmGenerator) stackOverflowModule() []byte {
	return []byte{
		0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
		0x01, 0x04, 0x01, 0x60, 0x00, 0x00,
		0x03, 0x02, 0x01, 0x00,
		0x07, 0x0c, 0x01, 0x08, 0x72, 0x65, 0x63, 0x75, 0x72, 0x73, 0x65, 0x00, 0x00,
		0x0a, 0x06, 0x01, 0x04, 0x00, 0x10, 0x00, 0x0b,
	}
}

type TestDataSet struct {
	Users    []TestUser    `json:"users"`
	Modules  []TestModule  `json:"modules"`
	Tasks    []TestTask    `json:"tasks"`
	Metrics  []TestMetric  `json:"metrics"`
}

type TestUser struct {
	ID       string   `json:"id"`
	Username string   `json:"username"`
	Password string   `json:"password"`
	Roles    []string `json:"roles"`
}

type TestModule struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	WasmData    []byte `json:"wasm_data"`
}

type TestTask struct {
	ID           string `json:"id"`
	ModuleID     string `json:"module_id"`
	Priority     int    `json:"priority"`
	SchedulerType string `json:"scheduler_type"`
}

type TestMetric struct {
	ModuleID  string  `json:"module_id"`
	Timestamp int64   `json:"timestamp"`
	Operations uint64 `json:"operations"`
	Memory    uint64  `json:"memory"`
	CPUTime   float64 `json:"cpu_time"`
}

func GenerateTestDataSet() *TestDataSet {
	gen := NewWasmGenerator()
	
	return &TestDataSet{
		Users: []TestUser{
			{"admin", "admin", "admin123", []string{"admin"}},
			{"dev1", "developer1", "dev123", []string{"developer"}},
			{"viewer1", "viewer1", "view123", []string{"viewer"}},
		},
		Modules: []TestModule{
			{"mod1", "Simple Add", "Basic addition module", gen.SimpleAddModule()},
			{"mod2", "Fibonacci", "Fibonacci calculator", gen.FibonacciModule()},
			{"mod3", "Memory Test", "Memory allocation test", gen.MemoryTestModule()},
		},
		Tasks: []TestTask{
			{"task1", "mod1", 5, "round_robin"},
			{"task2", "mod2", 8, "priority"},
			{"task3", "mod3", 3, "cooperative"},
		},
		Metrics: generateMetricsData(),
	}
}

func generateMetricsData() []TestMetric {
	metrics := make([]TestMetric, 100)
	baseTime := int64(1640995200) // 2022-01-01
	
	for i := 0; i < 100; i++ {
		metrics[i] = TestMetric{
			ModuleID:   fmt.Sprintf("mod%d", (i%3)+1),
			Timestamp:  baseTime + int64(i*60),
			Operations: uint64(100 + rand.Intn(900)),
			Memory:     uint64(1024 + rand.Intn(4096)),
			CPUTime:    math.Round(float64(rand.Intn(1000))/100*100) / 100,
		}
	}
	
	return metrics
}